% arara: lualatex
% arara: lualatex
% !arara: lualatex
% --------------------------------------------------------------------------
% the TRANSLATIONS package
% 
%   a simple translator
% 
% --------------------------------------------------------------------------
% Clemens Niederberger
% Web:    https://github.com/cgnieder/translations/
% E-Mail: contact@mychemistry.eu
% --------------------------------------------------------------------------
% Copyright 2011-2013 Clemens Niederberger
% 
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
% 
% This work has the LPPL maintenance status `maintained'.
% 
% The Current Maintainer of this work is Clemens Niederberger.
% --------------------------------------------------------------------------
% The translations package is part of the exsheets bundle
% --------------------------------------------------------------------------
% If you have any ideas, questions, suggestions or bugs to report, please
% feel free to contact me.
% --------------------------------------------------------------------------
%
% if you want to compile this documentation you'll need the document class
% `cnpkgdoc' which you can get here:
%    https://bitbucket.org/cgnieder/cnpkgdoc/
% the class is licensed LPPL 1.3 or later
%
% use `pdflatex' for compilation
%
\PassOptionsToPackage{supstfm=libertinesups}{superiors}
\documentclass[DIV11,toc=index,toc=bib,numbers=noendperiod]{cnpkgdoc}
% ----------------------------------------------------------------------------
% document layout and typographic features
\docsetup{
  pkg      = {translations} ,
  repo     = github ,
  subtitle = {internationalization of \LaTeXe\ packages} ,
  language = en ,
  modules  = true ,
  code-box = {
    skipbelow        = .6\baselineskip plus .5ex minus .5ex ,
    skipabove        = .6\baselineskip plus .5ex minus .5ex ,
    innerleftmargin  = 1.5em ,
    innerrightmargin = 2.5em ,
    roundcorner      = 3pt
  } ,
  gobble   = 1
}
\usepackage[oldstyle,proportional]{libertine}
\usepackage{libertinehologopatch}
\setmonofont[Scale=MatchLowercase]{Bitstream Vera Sans Mono}
\usepackage[english]{selnolig}
\cnpkgusecolorscheme{friendly}

\usepackage{embrac}[2012/06/29]
  \ChangeEmph{[}[,.02em]{]}[.055em,-.08em]
  \ChangeEmph{(}[-.01em,.04em]{)}[.04em,-.05em]
\usepackage{microtype}
\usepackage[multiple]{fnpct}

\renewcommand*\othersectionlevelsformat[3]{\textcolor{main}{#3\autodot}\enskip}
\renewcommand*\partformat{\textcolor{main}{\partname~\thepart\autodot}}

\pagestyle{headings}

\setcapindent{1.5em}
\setkomafont{caption}{\normalfont\footnotesize\sffamily}
\setkomafont{captionlabel}{\normalfont\footnotesize\sffamily\scshape}

\usepackage{booktabs,array,ragged2e}
\usepackage[sort]{cleveref}

% ----------------------------------------------------------------------------
% code examples
\addcmds{
  cuisine,
  DeclareDictTranslation, DeclareLanguage, DeclareLanguageAlias,
    DeclareLanguageDialect, DeclareTranslation, DeclareTranslationFallback,
  GetTranslation, GetTranslationFor,
  kitchen,
  LoadDictionary, LoadDictionaryFor,
  mypackage@title,
  NewTranslation,
  ProvideDictionaryFor,
  RenewTranslation,RequirePackage,
  SaveTranslation, SaveTranslationFor, selectlanguage
}

% ----------------------------------------------------------------------------
% other packages, bibliography, index
\usepackage{array,longtable,booktabs}

\usepackage{filecontents}
\usepackage{imakeidx}
\begin{filecontents*}{\jobname.ist}
 heading_prefix "{\\bfseries "
 heading_suffix "\\hfil}\\nopagebreak\n"
 headings_flag  1
 delim_0 "\\dotfill\\hyperpage{"
 delim_1 "\\dotfill\\hyperpage{"
 delim_2 "\\dotfill\\hyperpage{"
 delim_r "}\\textendash\\hyperpage{"
 delim_t "}"
 suffix_2p "\\nohyperpage{\\,f.}"
 suffix_3p "\\nohyperpage{\\,ff.}"
\end{filecontents*}
\indexsetup{othercode=\footnotesize}
\makeindex[options={-s \jobname.ist},intoc,columns=3]

% ----------------------------------------------------------------------------
% example definitions that have to be done in the preamble:
\DeclareTranslation{English}{Kueche}{kitchen}
\DeclareTranslation{German}{Kueche}{K\"uche}
\DeclareTranslation{Spanish}{Kueche}{cocina}
\DeclareTranslation{French}{Kueche}{cuisine}
\DeclareTranslation{English}{farbe}{color}
\DeclareTranslation{British}{farbe}{colour}
\LoadDictionaryFor{German}{translations-basic-dictionary}

% ----------------------------------------------------------------------------
% custom commands
\usepackage{bbding}

\newcommand*\required{\hfill\llap{required}\newline}
\newcommand*\optional{\hfill\llap{optional}\newline}

\newcommand*\unexpsign{{\tiny\FiveStar}}
\newcommand*\expsign{\textcolor{red}{{\tiny\FiveStar}}}
\renewcommand*\cnpkgdoctriangle{\unexpsign}
\newcommand*\expandable{%
  \def\cnpkgdoctriangle{%
    \expsign
    \gdef\cnpkgdoctriangle{\unexpsign}}}

\newlength\nodewidth
\setlength\nodewidth{.375\linewidth}
\long\def\yes:{\centering\textcolor{green}{\CheckmarkBold}\par}
\long\def\no:{\centering\textcolor{red}{\XSolidBrush}\par}
\protected\def\fnote#1{\textsuperscript{#1}}

\pdfstringdefDisableCommands{\def\llap#1{#1\space}\def\bigstar{*}}

\begin{document}

\section{Motivation}\secidx{Motivation}
This package provides means for package authors to have an easy interface for
internationalization of their packages.  The functionality of this package is
in many parts also covered by the package \paket*{translator} (part of the
\paket{beamer} bundle).  Internationalization is also possible with
\paket{babel} and it's \cmd*{addto}\cmd{captions<language>} mechanism or
\KOMAScript's \cmd{providecaptionname}.  However, I believe that
\translations\ is more flexible than all of these.  Unlike \paket*{translator}
it detects the used (\paket{babel} or \paket{polyglossia}) language itself and
provides expandable retrieving of the translated key.  \translations\ also
provides support for language dialects which means package authors can for
example distinguish between British, Australian, Canadian and US English.

The first draft of the package was written since I missed an expandable
version of \paket{translator}'s \cmd{translate} command.  Once I had the
package available I began using it in various of my other packages so it got
extended to the needs I faced there.
\secidx*{Motivation}

\section{License and Requirements}\label{sec:license}\secidx{Requirements}
\translations\ is placed under the terms of the \LaTeX{} Project Public
License, version 1.3 or later (\url{http://www.latex-project.org/lppl.txt}).
It has the  status ``maintained.''

\translations\ requires the packages \paket{etoolbox} and \paket*{scrlfile}
(part of the \KOMAScript\ bundle\footnote{\CTANurl{koma-script}}).
\secidx*{Requirements}

\section{Usage}\secidx{Usage}
\subsection{Background}\secidx[Background]{Usage}
The \translations\ package enables the author of a package or a class (or a
document) to declare translations in different languages of key words and
fetch these translations in the document depending on the active language as
set by \paket{babel} or \paket{polyglossia}.  Since \translations\ checks
which language is active it is generally not necessary to specify the language
for which a translation should be fetched manually.

\translations\ knows of three types of languages: main languages (see
\cref{tab:languages} on \cpageref{tab:languages}), language dialects (see
\cref{tab:dialects} on \cpageref{tab:dialects}) language aliases (see
\cref{tab:aliases} on \cpageref{tab:aliases}).  For the commands declaring or
fetching a translation base languages and language aliases are equivalent.
Dialects are similar to aliases but there are a few important differences.  An
alias can for example be an alias of a dialect.

\Cref{fig:scheme} shows what happens if \translations\ is asked to fetch a
translation for a given key.

\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}
    [
      level/.style={sibling distance=.5\linewidth/#1},
      every node/.style={
        draw,
        rounded corners=3pt,
        align=left,
        anchor=north,
        font=\small\sffamily
      }
    ]
    \node {check if any\fnote{a}  translation is defined in given language}
      child {
        node[text width=\nodewidth]
          {\yes: check if language is a dialect}
        child {
          node[text width=\nodewidth/2]
            {\yes: check if dialect translation is given}
          child {
            node[text width=\nodewidth/2.75]
              {\yes: use dialect translation}
          }
          child {
            node[text width=\nodewidth/2.75]
              {\no: use lan\-guage\fnote{b} translation}
          }
        }
        child {
          node[text width=\nodewidth/2]
            {\no: use translation}}
        }
      child {
        node[text width=\nodewidth]
          {\no: check if fallback translation is given}
        child {
          node[text width=\nodewidth/2.75]
            {\yes: use fallback translation}
        }
        child {
          node[text width=\nodewidth/2.75]
            {\no: use literal key}
        }
      } ;
  \end{tikzpicture}
  \caption{Schematic representation of \translations' translating
    mechansim. Notes: \fnote{a} except for a possible fallback
    translation. \fnote{b} \ie, the base language of the dialect.}
  \label{fig:scheme}
\end{figure}

What happens if you declare a translation? There are four cases:
\begin{enumerate}
  \item You declare a translation for a base language: this is the normal case
    where an internal macro is defined which can be fetched by the
    \cmd{GetTranslation} command (see \cref{ssec:commands}).
  \item You declare a translation for a language alias: this is the very same
    as the first case since the same internal macro is defined.
  \item You declare a translation for a dialect: this is two-fold.  Either a
    translation for the base language exists so only the translation for the
    dialect is saved.  If the translation for the base language does not exist
    it is defined to be the same as the one for the dialect.
  \item You daclare a translation for an alias of a dialect: this is the very
    same as the third case as again the internal macros are the same.
\end{enumerate}

\subsection{Available Commands}\label{ssec:commands}\secidx[Commands]{Usage}
Below the commands provided by \translations\ are explained.  The symbol
\expsign{} means that the command is expandable, \unexpsign{} means that it
isn't.
\begin{beschreibung}
 \Befehl{DeclareLanguage}{<lang>}\newline
   Declare a language that can be used by \translations. If the language
   already exists it will be silently redefined. This command can only be used
   in the preamble.
 \Befehl{DeclareLanguageAlias}{<lang2>}\ma{<lang1>}\newline
   Declares \code{<lang2>} to be an alias of \code{<lang1>}. If \code{<lang1>}
   doesn't exist yet a warning will be raised and it will be defined. This
   command can only be used in the preamble.
 \Befehl{DeclareLanguageDialect}{<dialect>}\ma{<lang>}\newline
   Declares \code{<dialect>} to be a dialect of language \code{<lang>}. If a
   translation for \code{<dialect>} is provided it is used by the translation
   macros. If there is none the corresponding translation for \code{<lang>} is
   used instead.
 \Befehl{NewTranslation}{<lang>}\ma{<key>}\ma{<translation>}\newline
   Defines a translation of key \code{<key>} for the language \code{<lang>}.
   An error will be raised if a translation of \code{<key>} already exists.
   This command can only be used in the preamble.
 \Befehl{RenewTranslation}{<lang>}\ma{<key>}\ma{<translation>}\newline
   Redefines a translation of key \code{<key>} for the language \code{<lang>}.
   An error will be raised if no translation of \code{<key>} exists.
   This command can only be used in the preamble.
 \Befehl{DeclareTranslation}{<lang>}\ma{<key>}\ma{<translation>}\newline
   Defines a translation of key \code{<key>} for the language \code{<lang>}.
   No error will be raised if a translation of \code{<key>} already exists.
   This command can only be used in the preamble.
 \Befehl{DeclareTranslationFallback}{<key>}\ma{<fallback>}\newline
   Defines a fallback translation for key \code{<key>} that is used in case no
   translation of \code{<key>} for the currently active language has been
   provided.  No error will be raised if a fallback for \code{<key>} already
   exists.  This command can only be used in the preamble.
 \expandable\Befehl{GetTranslationFor}{<lang>}\ma{<key>}\newline
   Fetches and prints the translation of \code{<key>} for the language
   \code{<lang>}.  This command is expandable.
 \expandable\Befehl{GetTranslation}{<key>}\newline
   Fetches and prints the translation of \code{<key>} for the currently active
   language (as for example set by \paket{babel}).  This command is expandable.
 \Befehl{GetTranslationForWarn}{<lang>}\ma{<key>}\newline
   \sinceversion{1.0}Fetches and prints the translation of \code{<key>} for
   the language \code{<lang>}.  Issues a warning if no translation is
   available.
 \Befehl{GetTranslationWarn}{<key>}\newline
   \sinceversion{1.0}Fetches and prints the translation of \code{<key>} for
   the currently active language (as for example set by \paket{babel}).
   Issues a warning if no translation is available.
 \Befehl{SaveTranslationFor}{<cmd>}\ma{<lang>}\ma{<key>}\newline
   Fetches and saves the translation of \code{<key>} for the language
   \code{<lang>} in the macro \code{<cmd>}.
 \Befehl{SaveTranslation}{<cmd>}\ma{<key>}\newline
   Fetches and saves the translation of \code{<key>} for the currently active
   language (as for example set by \paket{babel}) in the macro \code{<cmd>}.
 \Befehl{LoadDictionary}{<name>}\newline
   Loads a file named \code{<name>-<lang>.trsl} where \code{<lang>} corresponds
   to the lowercase name of the current language as defined with
   \cmd{DeclareLanguage}. This file should contain the translations for the
   specified language.
 \Befehl{LoadDictionaryFor}{<lang>}\ma{<name>}\newline
   Loads a file named \code{<name>-<lang>.trsl}.
 \Befehl{DeclareDictTranslation}{<key>}\ma{<translation>}\newline
   This command is to be used in a dictionary file and picks up the language
   of that file, see \cref{sec:dictionaries} for an example.
 \Befehl{ProvideDictionaryFor}{<lang>}\ma{<name>}\oa{<date>}\newline
   Needs to be in a dictionary file.  This command tells \translations\ that
   the file indeed is a dictionary and also sets the language for the
   dictionary which is used by \cmd{DeclareDictTranslation}.
 \expandable\Befehl{PrintDictionaryFor}{<lang>}\ma{<name>}\ma{<pre>}\ma{<mid>}\ma{<post>}\newline
   \sinceversion{1.0}Prints all entries of dictionary \code{<name>} in
   language \code{<lang>} in the order the entries have been declared.  For
   every entry the code\par
   \code{<pre><key><mid><translation><post>}\par
   is printed.  The dictionary must have been loaded of course.
\end{beschreibung}

\subsection{A Small Example}\secidx[Example]{Usage}
This section demonstrates with two short examples how the macros are used.
The first example covers the basics: dlaring of translations and then
retrieving and typesetting them.

\begin{beispiel}
 % in the preamble:
 % \DeclareTranslation{English}{Kueche}{kitchen}
 % \DeclareTranslation{German}{Kueche}{K\"uche}
 % \DeclareTranslation{Spanish}{Kueche}{cocina}
 % \DeclareTranslation{French}{Kueche}{cuisine}
 
 \GetTranslation{Kueche}
 \SaveTranslation\kitchen{Kueche}
 \SaveTranslationFor\cuisine{french}{Kueche}

 \selectlanguage{ngerman}
 \GetTranslation{Kueche} \kitchen\ \GetTranslationFor{spanish}{Kueche}
 \cuisine
\end{beispiel}

The next example demonstrates the use of dialects and how they fall back to
the translation for the main language if no extra translation was declared:

\begin{beispiel}
 % in the preamble:
 % \DeclareTranslation{English}{farbe}{color}
 % \DeclareTranslation{British}{farbe}{colour}

 \GetTranslationFor{English}{farbe} \\
 \GetTranslationFor{British}{farbe} \\
 \GetTranslationFor{American}{farbe}
\end{beispiel}

\subsection{Usage in Packages}\secidx[Packages]{Usage}
\subsubsection{Basic Structure}\secidx[Packages!structure]{Usage}
A typical usage in a package would look as follows:
\begin{beispiel}[code only]
 \RequirePackage{translations}
 \DeclareTranslationFallback{mypackage-title}{Nice Title}
 \DeclareTranslation{English}{mypackage-title}{Nice Title}
 \DeclareTranslation{French}{mypackage-title}{Beau Titre}
 \DeclareTranslation{German}{mypackage-title}{Sch\"{o}ner Titel} 
 ...
 \def\mypackage@title{\GetTranslation{mypackage-title}}
\end{beispiel}

That is, a package defines some unique key for an expression and at least
defines a fallback translation.  Additionally translations for as many
languages as the author wants are defined.  A user then may add
\cmd{DeclareTranslation}\ma{<language>}\ma{<translation>} if they find their
translation missing.

\subsubsection{The `fallback' language}\secidx[Packages!fallback]{Usage}
If a user has neither loaded \paket{babel} nor \paket{polyglossia}
\translations\ will use English as language and translate to English if the
translation was provided.  If the user \emph{has} loaded one of the language
packages but has chosen a language for which no translation is defined the
language `fallback' will be used, i.e., the translation provided with
\cmd{DeclareTranslationFallback}.  If no fallback translation is provided
either the translation will expand to the literal string.

The following three examples should make this concept clear:

\begin{beispiel}[code only]
 \documentclass{article}
 \DeclareTranslation{German}{foo-literal}{bar}
 \begin{document}
 \GetTranslation{foo-literal} => `foo-literal'
 \end{document}
\end{beispiel}

\begin{beispiel}[code only]
 \documentclass{article}
 \DeclareTranslationFallback{foo-literal}{foo}
 \DeclareTranslation{German}{foo-literal}{bar}
 \begin{document}
 \GetTranslation{foo-literal} => `foo'
 \end{document}
\end{beispiel}

\begin{beispiel}[code only]
 \documentclass{article}
 \usepackage[ngerman]{babel}
 \DeclareTranslation{German}{foo-literal}{bar}
 \begin{document}
 \GetTranslation{foo-literal} => `bar'
 \end{document}
\end{beispiel}

\subsection{Dictionaries}\label{sec:dictionaries}
\secidx{Dictionaries}\secidx[Dictionaries]{Usage}
\subsubsection{Own Dictionaries}\secidx[own]{Dictionaries}
A typical dictionary file should look as follows:
\begin{beispiel}[code only]
 % this is file housing-german.trsl
 \ProvideDictionaryFor{German}{housing}[<version info>]
 \DeclareDictTranslation{kitchen (housing)}{K\"uche}
 \DeclareDictTranslation{bathroom (housing)}{Bad}
 \DeclareDictTranslation{living room (housing)}{Wohnzimmer}
 \DeclareDictTranslation{bedroom (housing)}{Schlafzimmer}
 ...
 \endinput
\end{beispiel}

The usage is similar to the one in a package: unique keys are given
translations, this time for the language the dictionary file is declared for
only.

\subsubsection{\translations' Basic Dictionaries}\secidx[basic]{Dictionaries}
\translations\ already provides a basic dictionary for the languages English,
French, German and Spanish.  This dictionary is loaded automatically if the
document language is one of these four.  If you'd like to contribute and add
the basic dictionary in your language this is more than welcome and highly
appreciated!  The easiest way to do this would be to copy one of the existing
files \code{translations-basic-dictionary-<lang>.trsl} and modify the file
accordingly.  You can then send me the file via email and I'll add it to
\translations.

\Cref{tab:dict} lists all words provided by the basic dictionary for German.

\begin{longtable}{ll}
    \caption{All entries of \translations' basic dictionary in German.\label{tab:dict}} \\
    \toprule
    \rmfamily\bfseries key & \bfseries translation \\
    \midrule
  \endfirsthead
    \toprule
    \rmfamily\bfseries key & \bfseries translation \\
    \midrule
  \endhead
    \bottomrule
  \endlastfoot
    \midrule
    & \hfill\emph{continues} \\
  \endfoot
  \PrintDictionaryFor{German}{translations-basic-dictionary}{\ttfamily}{&}{\\}
\end{longtable}

\secidx*{Dictionaries}
\secidx*{Usage}

\section{Defined Languages}\label{sec:languages}\secidx{Languages}
\subsection{Base Languages}
Quite a number of languages already are defined, either directly or via an
alias.  So, before you define a language you should take a look at the tables
below if the language doesn't already exist.  \Cref{tab:languages} lists all
base languages, ``fallback'' being a dummy language used for fallback
translations.  \Cref{tab:languages,tab:dialects,tab:aliases} list \emph{all}
language names known to \translations.  However, they're not sorted
alphabetically but listed in the order they have been defined.  I tried to
make the definitions in an alphabetical order but sometimes rather grouped
related language names together.

If you miss a language or recognize a language that has falsely been declared
as an alias but should rather be a dialect or base language itself (or any
variation of this theme) please let me know, preferably with a short
explanation what's wrong and why.

\newcounter{column}
\gdef\seplang{%
  \stepcounter{column}%
  \ifnumless{\value{column}}{5}
    {&}
    {\\\setcounter{column}{0}}%
}
\def\do#1{#1\seplang}
\makeatletter
\begin{longtable}{lllll}
    \caption{Base languages defined by \translations, from left to right in
      the order of definition.\label{tab:languages}} \\
    \toprule
  \endfirsthead
    \toprule
  \endhead
    \bottomrule
  \endlastfoot
    \midrule
    &&& \hfill\emph{continues} \\
  \endfoot
  \dolistloop\@trnslt@languages
\end{longtable}
\makeatother

\subsection{Language Dialects}
\translations\ also defines a few dialects of thebase languages.  They are
listed in \cref{tab:dialects}.  The decision what is a dialect and what is an
alias is not always clear.  I am no linguist so I looked up information
available on the internet.  A language that was described as
\enquote{standardized register} was always defined as a dialect.  For some
other languages it seemed to make sense, such as British or Austrian.  The
decisions are open for debate.

\setcounter{column}{0}
\gdef\seplang{%
  \ifnumgreater{\value{column}}{3}
    {\setcounter{column}{1}}
    {\stepcounter{column}}%
  \ifnumless{\value{column}}{4}
    {&}
    {\\}%
}
\def\aliases#1#2{#1\seplang #2\seplang}
\def\do#1{\aliases#1}
\makeatletter
\begin{longtable}{ll@{\hspace*{4em}}ll}
    \caption{All dialects defined by \translations, from left to right in the
      order of definition.\label{tab:dialects}}\\
    \toprule
     \bfseries dialect & \bfseries language &
     \bfseries dialect & \bfseries language \\
    \midrule
  \endfirsthead
    \toprule
     \bfseries dialect & \bfseries language &
     \bfseries dialect & \bfseries language \\
    \midrule
  \endhead
    \bottomrule
  \endlastfoot
    \midrule
    &&& \hfill\emph{continues} \\
  \endfoot
  \dolistloop\@trnslt@dialects@pair
\end{longtable}
\makeatother

\subsection{Language Aliases}
To most of the base languages and dialects at least one alias exists, the
uppercase variant.  This is due to the fact that it is common to write
language names uppercased.  For a number of languages aliases were defined in
order to match \paket{babel}'s or \paket{polyglossia}'s names for the
languages.  Others are defined because there apparently exist more than one
name for the same language.  The decisions are not consistent.  For example it
could be argued that \enquote{deutsch} is an alias of \enquote{German}.  I am
open to suggestions and improvements.  All defined aliases are listed in
\cref{tab:aliases}.

\setcounter{column}{0}
\makeatletter
\begin{longtable}{ll@{\hspace*{4em}}ll}
    \caption{All language aliases defined by \translations, from left to right
      in the order of definition.\label{tab:aliases}}\\
    \toprule
     \bfseries alias & \bfseries language &
     \bfseries alias & \bfseries language \\
    \midrule
  \endfirsthead
    \toprule
     \bfseries alias & \bfseries language &
     \bfseries alias & \bfseries language \\
    \midrule
  \endhead
    \bottomrule
  \endlastfoot
    \midrule
    &&& \hfill\emph{continues} \\
  \endfoot
  \dolistloop\@trnslt@aliases@pair
\end{longtable}
\makeatother

\secidx*{Languages}

These languages \emph{should} cover all languages which are currently covered
by \paket{babel} and \paket{polyglossia} but very likely this is not the
case.  Should you miss a language please send me an email so I can add it to
\translations.

\section{Implementation}\index{Implementation@\textbf{Implementation}}
In the following code the lines 1--30 have been omitted. They only repeat the
license statement which has already been mentioned in \cref{sec:license}.

\implementation[linerange={31-1000},firstnumber=31]

\indexprologue{\noindent Section titles are indicated \textbf{bold}, packages
  \textsf{sans serif} and commands
  \code{\textbackslash\textcolor{code}{brown}}.\par\bigskip}

\printindex

\end{document}
